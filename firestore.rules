// C:\entretenimento\firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ========= Helpers =========
    function signedIn() { return request.auth != null; }
    function uid() { return request.auth.uid; }
    function isSelf(userId) { return signedIn() && uid() == userId; }

    function isStr(v) { return v is string; }
    function isNum(v) { return v is number; }
    function isBool(v) { return v is bool; }
    function isTs(v) { return v is timestamp; }

    function optString(k) {
      return !(k in request.resource.data)
        || request.resource.data[k] is string
        || request.resource.data[k] == null;
    }

    function optNumberOrNull(k) {
      return !(k in request.resource.data)
        || request.resource.data[k] is number
        || request.resource.data[k] == null;
    }

    function optBool(k) {
      return !(k in request.resource.data) || request.resource.data[k] is bool;
    }

    function optTimestamp(k) {
      return !(k in request.resource.data) || request.resource.data[k] is timestamp;
    }

    // =========================================================================
    // USERS (privado)
    // =========================================================================
    match /users/{userId} {
      allow get, create, update: if isSelf(userId);
      allow list: if false;
      allow delete: if false;
    }

    match /users/{userId}/friends/{friendId} {
      allow read, write: if isSelf(userId);
    }

    // ✅ ajuste o nome conforme seu app usa (blocks OU blocked)
    match /users/{userId}/blocks/{targetId} {
      allow read, write: if isSelf(userId);
    }

    // =========================================================================
    // PUBLIC PROFILES (consultável / discovery)
    // - Fonte do discovery (search/filtros)
    // - NÃO contém dados privados (email, phone, etc.)
    // =========================================================================
    match /public_profiles/{userId} {
      // Recomendação: exige login para ler perfis públicos (padrão do seu projeto)
      allow get, list: if signedIn();

      // Se você quiser perfis públicos sem login (não recomendo no seu caso):
      // allow get, list: if true;

      function allowedKeys() {
        return request.resource.data.keys().hasOnly([
          "uid",
          "nickname",
          "nicknameNormalized",
          "avatarUrl",   // padrão recomendado (ou use photoURL, mas escolha 1)
          "photoURL",    // opcional de compat (se você ainda usa isso)
          "municipio",
          "estado",
          "gender",
          "orientation",
          "role",
          "latitude",
          "longitude",
          "geohash",
          "createdAt",
          "updatedAt"
        ]);
      }

      function validPublicProfilePayload() {
        return request.resource.data.uid == uid()
          && allowedKeys()
          && optString("nickname")
          && optString("nicknameNormalized")
          && optString("avatarUrl")
          && optString("photoURL")
          && optString("municipio")
          && optString("estado")
          && optString("gender")
          && optString("orientation")
          && optString("role")
          && optNumberOrNull("latitude")
          && optNumberOrNull("longitude")
          && optString("geohash")
          && optTimestamp("createdAt")
          && optTimestamp("updatedAt");
      }

      allow create: if (
        isSelf(userId)
        && validPublicProfilePayload()
        && isTs(request.resource.data.createdAt)
        && isTs(request.resource.data.updatedAt)
        && request.resource.data.role == "basic"
      );

      allow update: if (
        isSelf(userId)
        && validPublicProfilePayload()
        && request.resource.data.createdAt == resource.data.createdAt
        && isTs(request.resource.data.updatedAt)
        && request.resource.data.role == resource.data.role
      );

      allow delete: if false;
    }

    // =========================================================================
    // PRESENCE (efêmero / realtime)
    // =========================================================================
match /presence/{presenceUid} {
  allow read: if signedIn();

  allow create, update: if (
    isSelf(presenceUid)
    && request.resource.data.uid == uid()
    && request.resource.data.keys().hasOnly([
      "uid",
      "presenceSessionId",

      "isOnline",
      "presenceState",

      "lastSeen",
      "updatedAt",

      "lastStateChangeAt",
      "lastOnlineAt",
      "lastOfflineAt",

      "nickname",
      "municipio",
      "estado",
      "photoURL",
      "latitude",
      "longitude"
    ])

    && request.resource.data.presenceSessionId is string

    && request.resource.data.isOnline is bool
    && request.resource.data.presenceState in ["online","away","offline"]

    && request.resource.data.lastSeen is timestamp
    && optTimestamp("updatedAt")

    && optTimestamp("lastStateChangeAt")
    && optTimestamp("lastOnlineAt")
    && optTimestamp("lastOfflineAt")

    && optString("nickname")
    && optString("municipio")
    && optString("estado")
    && optString("photoURL")
    && optNumberOrNull("latitude")
    && optNumberOrNull("longitude")
  );
  allow delete: if false;
}

    // =========================================================================
    // FRIEND REQUESTS
    // =========================================================================
    match /friendRequests/{reqId} {
      allow read: if signedIn() &&
        (resource.data.requesterUid == uid() ||
         resource.data.targetUid    == uid());

      allow create: if signedIn()
        && request.resource.data.requesterUid == uid()
        && request.resource.data.targetUid    != uid()
        && request.resource.data.status       == 'pending'
        && request.resource.data.createdAt    is timestamp;

      allow update: if signedIn()
        && resource.data.status == 'pending'
        && request.resource.data.status in ['accepted','declined']
        && uid() == resource.data.targetUid
        && request.resource.data.respondedAt is timestamp
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status','respondedAt']);

      allow delete: if signedIn()
        && resource.data.status == 'pending'
        && uid() == resource.data.requesterUid;
    }

    // =========================================================================
    // CHATS
    // =========================================================================
    match /chats/{chatId} {
      function isChatParticipant() {
        return signedIn() && (uid() in resource.data.participants);
      }

      allow read: if isChatParticipant();

      allow create: if signedIn()
        && (uid() in request.resource.data.participants)
        && request.resource.data.participants is list
        && request.resource.data.participants.size() >= 2
        && isTs(request.resource.data.timestamp)
        && (!('participantsKey' in request.resource.data) || isStr(request.resource.data.participantsKey));

      allow update: if isChatParticipant()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly([
          "lastMessage",
          "otherParticipantDetails",
          "timestamp"
        ]);

      allow delete: if false;
    }

    match /chats/{chatId}/messages/{messageId} {
      function isChatParticipantByChat() {
        return signedIn()
          && (uid() in get(/databases/$(database)/documents/chats/$(chatId)).data.participants);
      }

      function senderIsMeCreate() {
        return (request.resource.data.senderId == uid())
          || (("senderUid" in request.resource.data) && request.resource.data.senderUid == uid());
      }

      function messageHasTime() {
        return (("timestamp" in request.resource.data) && isTs(request.resource.data.timestamp))
          || (("createdAt" in request.resource.data) && isTs(request.resource.data.createdAt));
      }

      allow read: if isChatParticipantByChat();

      allow create: if isChatParticipantByChat()
        && senderIsMeCreate()
        && isStr(request.resource.data.content) && request.resource.data.content.size() > 0
        && isStr(request.resource.data.nickname)
        && messageHasTime()
        && (!("status" in request.resource.data) || request.resource.data.status == "sent");

      allow update: if isChatParticipantByChat()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["status"])
        && request.resource.data.status in ["delivered","read"]
        && (
          (("senderId" in resource.data) && resource.data.senderId != uid())
          ||
          (("senderUid" in resource.data) && resource.data.senderUid != uid())
        );

      allow delete: if false;
    }

    // =========================================================================
    // ROOMS
    // =========================================================================
    match /rooms/{roomId} {
      function isRoomParticipant() {
        return signedIn() && (uid() in resource.data.participants);
      }
      function isRoomOwner() {
        return signedIn() && resource.data.createdBy == uid();
      }

      allow read: if isRoomParticipant();

      allow create: if signedIn()
        && request.resource.data.createdBy == uid()
        && request.resource.data.participants is list
        && (uid() in request.resource.data.participants)
        && isStr(request.resource.data.roomName)
        && ("creationTime" in request.resource.data) && isTs(request.resource.data.creationTime);

      allow update: if isRoomParticipant()
        && (
          (isRoomOwner()
            && request.resource.data.diff(resource.data).changedKeys().hasOnly([
              "roomName",
              "description",
              "expirationDate",
              "maxParticipants",
              "isPrivate",
              "roomType",
              "visibility",
              "participants",
              "lastActivity",
              "lastMessage"
            ])
          )
          ||
          (!isRoomOwner()
            && request.resource.data.diff(resource.data).changedKeys().hasOnly([
              "lastActivity",
              "lastMessage"
            ])
          )
        );

      allow delete: if false;
    }

    match /rooms/{roomId}/messages/{messageId} {
      function isRoomParticipantByRoom() {
        return signedIn()
          && (uid() in get(/databases/$(database)/documents/rooms/$(roomId)).data.participants);
      }

      function senderIsMeCreate() {
        return (request.resource.data.senderId == uid())
          || (("senderUid" in request.resource.data) && request.resource.data.senderUid == uid());
      }

      function messageHasTime() {
        return (("timestamp" in request.resource.data) && isTs(request.resource.data.timestamp))
          || (("createdAt" in request.resource.data) && isTs(request.resource.data.createdAt));
      }

      allow read: if isRoomParticipantByRoom();

      allow create: if isRoomParticipantByRoom()
        && senderIsMeCreate()
        && isStr(request.resource.data.content) && request.resource.data.content.size() > 0
        && isStr(request.resource.data.nickname)
        && messageHasTime()
        && (!("status" in request.resource.data) || request.resource.data.status == "sent");

      allow update: if isRoomParticipantByRoom()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["status"])
        && request.resource.data.status in ["delivered","read"]
        && (
          (("senderId" in resource.data) && resource.data.senderId != uid())
          ||
          (("senderUid" in resource.data) && resource.data.senderUid != uid())
        );

      allow delete: if false;
    }

    match /rooms/{roomId}/invites/{inviteId} {
      function canSeeInvite() {
        return signedIn()
          && (resource.data.senderId == uid() || resource.data.receiverId == uid());
      }

      allow read: if canSeeInvite();

      allow create: if signedIn()
        && request.resource.data.senderId == uid()
        && request.resource.data.roomId == roomId
        && request.resource.data.receiverId != uid()
        && request.resource.data.status == "pending"
        && isTs(request.resource.data.sentAt)
        && isTs(request.resource.data.expiresAt)
        && isStr(request.resource.data.roomName);

      allow update: if signedIn()
        && resource.data.status == "pending"
        && resource.data.receiverId == uid()
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(["status"])
        && request.resource.data.status in ["accepted","declined"];

      allow delete: if signedIn()
        && resource.data.status == "pending"
        && resource.data.senderId == uid();
    }

        // =========================================================================
        // PUBLIC INDEX (índice técnico)
        // - nickname: leitura pública (sem login) para validação em /register
        // - email: privado do dono
        // =========================================================================
        match /public_index/{docId} {

          function isNicknameDoc() { return docId.matches('^nickname:.+'); }
          function isEmailDoc() { return docId.matches('^email:.+'); }

          // ✅ GET público para nickname (registro sem login)
          // ✅ GET privado para email (somente dono logado)
          allow get: if isNicknameDoc()
            || (signedIn() && isEmailDoc() && resource.data.uid == uid());

          allow list: if false;

          function validDocId() {
            return isNicknameDoc() || isEmailDoc();
          }

          function common() {
            return signedIn()
              && validDocId()
              && request.resource.data.uid == uid()
              && request.resource.data.type in ["nickname","email"]
              && request.resource.data.value is string
              && request.resource.data.createdAt is timestamp
              && request.resource.data.lastChangedAt is timestamp;
          }

          // create-only (continua exigindo login — pq a criação ocorre após createUser)
          allow create: if common()
            && !exists(/databases/$(database)/documents/public_index/$(docId));

          // nickname: update bloqueado | email: update permitido (se você quiser)
          allow update: if signedIn()
            && isEmailDoc()
            && request.resource.data.uid == uid()
            && request.resource.data.type == "email"
            && request.resource.data.value is string
            && request.resource.data.createdAt == resource.data.createdAt
            && request.resource.data.lastChangedAt is timestamp;

          // delete: dono pode apagar (útil p/ troca controlada)
          allow delete: if signedIn() && resource.data.uid == uid();
    }
  }
}//428 linhas
